<?php

declare(strict_types=1);

namespace gugglegum\CommandLine;

use gugglegum\CommandLine\Options\Option;
use gugglegum\CommandLine\Options\OptionFlag;

/**
 * Console command help page generation class
 *
 * This class takes into constructor config of command line parameters and produces formatted text page of help which
 * usually printed by specifying "--help" option.
 *
 * @package gugglegum\CommandLine
 */
class Help
{
    /**
     * Description of a command. It will be placed at the top of help page. Too long description will be automatically
     * split by words on several lines according to $maxWidth property.
     *
     * @var string
     */
    protected $description;

    /**
     * The pattern for "usage" part of help page. The macro "%synopsis%" will be replaced by command and arguments list.
     *
     * @var string
     */
    protected $usagePattern = "Usage:\n\n%synopsis%";

    /**
     * The pattern for "arguments" part of help page. The macro "%argumentRows%" will be replaced by formatted list
     * of argument hints.
     *
     * @var string
     */
    protected $argumentsPattern = "Arguments:\n\n%argumentRows%";

    /**
     * The pattern for "options" part of help page. The macro "%optionRows%" will be replaced by formatted list of
     * option hints.
     *
     * @var string
     */
    protected $optionsPattern = "Options:\n\n%optionRows%";

    /**
     * Maximum width of help page (in characters). All texts will shrink to fit this width.
     *
     * @var int
     */
    protected $maxWidth = 80;

    /**
     * Maximum width of left column used for names of arguments and options (including padding). If length of some
     * argument or option becomes longer this value -- the description will be moved on the next line.
     *
     * @var int
     */
    protected $maxLeftColumnWidth = 25;

    /**
     * Padding width. Used in arguments and options list on left side.
     *
     * @var int
     */
    protected $padWidth = 4;

    /**
     * Command executable name used in the beginning of synopsis of usage part. If not defined used default value
     * generated by `'php ' . basename($_SERVER['PHP_SELF'])`.
     *
     * @var string|null
     */
    protected $commandExecutable;

    /**
     * Typically "[OPTIONS]" inserted into "usage" part after command executable and before arguments if config contains
     * expected options.
     *
     * @var string
     */
    protected $usageOptionsWord = '[OPTIONS]';

    /**
     * The pattern of argument in synopsis of usage part.
     *
     * @var string
     */
    protected $usageArgumentPattern = '<%argument%>';

    /**
     * @var bool
     */
    protected $alignLongOptions = false;

    /**
     * The encoding of text.
     *
     * @var string
     */
    protected $encoding = 'UTF-8';

    /**
     * The config of command line parameters usually passed in Parser::parse() method.
     *
     * @var Config
     */
    protected $config;

    /**
     * Help constructor
     *
     * @param Config $config
     * @param array  $params
     * @throws Exception
     */
    public function __construct(Config $config, array $params = [])
    {
        $this->config = $config;
        foreach ($params as $key => $value) {
            if (property_exists($this, $key)) {
                $this->{$key} = $value;
            } else {
                throw new Exception("Unknown parameter '{$key}'");
            }
        }
    }

    /**
     * Composes whole help page
     *
     * @return string
     */
    public function compose(): string
    {
        $helpSections = [];
        if ($this->description !== null) {
            $helpSections[] = implode("\n", $this->splitByWords($this->description, $this->maxWidth)) . "\n";
        }
        $helpSections[] = $this->getUsage();

        if ($this->config->hasArguments()) {
            $helpSections[] = $this->getArguments();
        }

        if ($this->config->hasOptions()) {
            $helpSections[] = $this->getOptions();
        }
        return implode("\n", $helpSections);
    }

    /**
     * Composes "usage" part of help message
     *
     * @return string
     */
    protected function getUsage(): string
    {
        $synopsis = $this->getCommandExecutable();
        if (count($this->config->getOptions()) > 0) {
            $synopsis .= " {$this->usageOptionsWord}";
        }

        $arguments = $this->config->getArguments();
        $argumentIndex = 0;
        $openedBrackets = 0;
        foreach ($arguments as $argument) {

            $synopsis .= ' ';

            if ($argument->isOptional()) {
                $synopsis .= '[';
                $openedBrackets++;
            }
            $synopsis .= str_replace('%argument%', $argument->getName(), $this->usageArgumentPattern);

            $argumentIndex++;
        }

        if ($openedBrackets > 0) {
            $synopsis .= str_repeat(']', $openedBrackets);
        }

        $pad = str_repeat(' ', $this->padWidth);
        return str_replace([ '%synopsis%' ], [
            $pad . implode("\n{$pad}", $this->splitByWords($synopsis, $this->maxWidth - $this->padWidth))
            . "\n"
        ], $this->usagePattern);
    }

    /**
     * Composes "arguments" part of help message
     *
     * @return string
     */
    protected function getArguments(): string
    {
        $argumentRows = '';
        foreach ($this->config->getArguments() as $argument) {
            $argumentRows .= $this->getArgumentRow($argument) . "\n";
        }
        return str_replace([ '%argumentRows%' ], [ $argumentRows ], $this->argumentsPattern);
    }

    /**
     * Used in getArguments() method to compose help of every single argument
     *
     * @param Argument $argument
     * @return string
     */
    protected function getArgumentRow(Argument $argument): string
    {
        $row = str_repeat(' ', $this->padWidth);
        if (mb_strlen($argument->getName(), $this->encoding) + $this->padWidth <= $this->getArgumentsLeftColumnWidth()) {
            $row .= str_pad($argument->getName(), $this->getArgumentsLeftColumnWidth(), ' ', STR_PAD_RIGHT);
        } else {
            $row .= $argument->getName() . "\n" . str_repeat(' ', $this->padWidth + $this->getArgumentsLeftColumnWidth());
        }

        if ($argument->hasDescription()) {
            $row .= implode(
                "\n" . str_repeat(' ', $this->padWidth + $this->getArgumentsLeftColumnWidth()),
                $this->splitByWords($argument->getDescription(), $this->maxWidth - $this->getArgumentsLeftColumnWidth() - $this->padWidth)
            );
        }
        return $row;
    }

    /**
     * Composes "options" part of help message
     *
     * @return string
     */
    protected function getOptions(): string
    {
        $optionRows = '';
        foreach ($this->config->getOptions() as $option) {
            $optionRows .= $this->getOptionRow($option) . "\n";
        }
        return str_replace([ '%optionRows%' ], [ $optionRows ], $this->optionsPattern);
    }

    /**
     * Used in getOptions() method to compose help of every single argument
     *
     * @param Option $option
     * @return string
     */
    protected function getOptionRow(Option $option): string
    {
        $row = str_repeat(' ', $this->padWidth);
        $syntax = $this->getOptionSyntax($option);
        if (mb_strlen($syntax, $this->encoding) + $this->padWidth <= $this->getOptionsLeftColumnWidth()) {
            $row .= str_pad($syntax, $this->getOptionsLeftColumnWidth(), ' ', STR_PAD_RIGHT);
        } else {
            $row .= $syntax . "\n" . str_repeat(' ', $this->padWidth + $this->getOptionsLeftColumnWidth());
        }

        if ($option->hasDescription()) {
            $row .= implode(
                "\n" . str_repeat(' ', $this->padWidth + $this->getOptionsLeftColumnWidth()),
                $this->splitByWords($option->getDescription(), $this->maxWidth - $this->getOptionsLeftColumnWidth() - $this->padWidth)
            );
        }
        return $row;
    }

    protected function getOptionSyntax(Option $option): string
    {
        $optionNames = '';
        if ($option->hasShortName()) {
            $optionNames .= '-' . $option->getShortName();
        }
        if ($option->hasLongName()) {
            if ($option->hasShortName()) {
                $optionNames .= ', ';
            } elseif ($this->alignLongOptions) {
                $optionNames .= str_repeat(' ', 4);
            }
            $optionNames .= '--' . $option->getLongName();
            if (!$option instanceof OptionFlag) {
                $optionNames .= '=' . $option->getValueName();
            }
        } else {
            if (!$option instanceof OptionFlag) {
                $optionNames .= ' ' . $option->getValueName();
            }
        }
        return $optionNames;
    }

    /**
     * Returns command executable used in the beginning of synopsis of usage part. If not defined used default value
     * generated by `'php ' . basename($_SERVER['PHP_SELF'])`.
     *
     * @return string
     */
    protected function getCommandExecutable(): string
    {
        return $this->commandExecutable !== null
            ? $this->commandExecutable
            : 'php ' . basename($_SERVER['PHP_SELF']);
    }

    /**
     * Calculates the actual width of left column in arguments part based on $maxLeftColumnWidth and maximum length
     * of all arguments including padding.
     *
     * @return int
     */
    protected function getArgumentsLeftColumnWidth(): int
    {
        return min($this->maxLeftColumnWidth, $this->getMaxArgumentLength() + $this->padWidth);
    }

    /**
     * Calculates maximum argument length of all arguments
     *
     * @return int
     */
    protected function getMaxArgumentLength(): int
    {
        static $maxLength;

        if ($maxLength === null) {
            $maxLength = 0;
            foreach ($this->config->getArguments() as $argument) {
                if (($length = mb_strlen($argument->getName(), $this->encoding)) > $maxLength) {
                    $maxLength = $length;
                }
            }
        }

        return $maxLength;
    }

    /**
     * Calculates the actual width of left column in options part based on $maxLeftColumnWidth and maximum length
     * of all long options including padding.
     *
     * @return int
     */
    protected function getOptionsLeftColumnWidth(): int
    {
        return min($this->maxLeftColumnWidth, $this->getMaxLongOptionLength() + $this->padWidth);
    }

    /**
     * Calculates maximum argument length of all long options
     *
     * @return int
     */
    protected function getMaxLongOptionLength(): int
    {
        static $maxLength;

        if ($maxLength === null) {
            $maxLength = 0;
            foreach ($this->config->getOptions() as $option) {
                $syntax = $this->getOptionSyntax($option);
                if (($length = mb_strlen($syntax, $this->encoding)) > $maxLength) {
                    $maxLength = $length;
                }
            }
        }

        return $maxLength;
    }

    /**
     * Splits long string by words into several shorter parts. It also takes into account LF ("\n") character as a
     * line separator.
     *
     * @param string $str
     * @param int    $maxLength
     * @return string[]             Array of strings
     */
    protected function splitByWords(string $str, int $maxLength): array
    {
        $lines = [];
        $lineStartOffset = 0;
        $lastSpaceOffset = null;
        for ($i = 0; $i < mb_strlen($str, $this->encoding); $i++) {
            if (mb_substr($str, $i, 1) === ' ') {
                $lastSpaceOffset = $i;
            }
            if (mb_substr($str, $i, 1) === "\n") {
                $lines[] = mb_substr($str, $lineStartOffset, $i - $lineStartOffset, $this->encoding);
                $lineStartOffset = $i + 1;
            }
            if ($i - $lineStartOffset >= $maxLength) {
                if ($lastSpaceOffset) {
                    $lines[] = mb_substr($str, $lineStartOffset, $lastSpaceOffset - $lineStartOffset, $this->encoding);
                    $lineStartOffset = $lastSpaceOffset + 1;
                } else {
                    $lines[] = mb_substr($str, $lineStartOffset, $i - $lineStartOffset, $this->encoding);
                    $lineStartOffset = $i;
                }
                $lastSpaceOffset = null;
            }
        }
        $lines[] = mb_substr($str, $lineStartOffset, null, $this->encoding);
        return $lines;
    }
}
